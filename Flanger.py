# -*- coding: utf-8 -*-
"""Flanger.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vQsJ47LLeWHjoa3O_x0JY9k2HmSkm8Ss
"""

import numpy as np

delay        = 0.01
mod_width    = 0.003
mod_freq     = 1
fs           = 44.1E03 # sampling rate for audio CDs
ratio        = mod_freq / fs
M0           = np.floor(fs * delay)
width        = np.floor(fs * mod_width)
Nl           = 0.5 * fs
g            = 1 # notch depth [0,1]
phase        = 0
i_n          = 0
# maximum delay
# L = fs(delay + mod_width) + 2
delay_length = M0 + width + 2 # f441 + f132.3 + 2 = 575
delay_buffer = np.zeros(delay_length)

def lfo(i=1):
  global phase
  # no. of notches
  # if phase [offset = 0, 1/8], then [M0, fs(delay + md_width)]
  Mn = M0 + width*np.sin(2*np.pi*phase)
  # evolution of phase
  phase  = phase + (i * ratio)
  # closure over the phase, sin over one single period
  if(phase > 1.0):
    phase = phase - 1.0
  return Mn

def delay_line(i_m):
  global i_n, delay_buffer
  # We force index from zero and above for inputs
  idx = i_n - i_m
  if idx < 0:
    idx = idx + delay_length
  return delay_buffer[idx]

def push(sample):
  global i_n, delay_buffer
   # push sample and closure on/over superior limit
  delay_buffer[i_n] = sample
  i_n = i_n + 1
  if i_n + 1 >= delay_length:
    i_n = i_n - delay_length

def flanger(x):
# We are on digital domain so we're forced to clip the delay line
  m = np.floor(lfo())
  # how far in between [n-M, n-M+1] we want to find a value to compensate
  # for the previous
  eta = lfo() - m
  # Le pasamos el retardo digital m
  x_eta = ((1 - eta) * delay_line(m)) + (eta * delay_line(m + 1))

  push(x)
  return x + g * x_eta

def main():
  for i in range(len(signal)):
    y[i] = flanger(signal[i])
  y = y / max(np.abs(y))

  if __name__ == "__main__":
    main()

"""Since $M(n)$ must vary smoothly over time, it is clearly neccesary to use an interpolated delay line to provide non-integer values of $M$ in a smooth fashion

Linearly interpolated delay line $$x((n-M)+\eta)=\eta x((n-M)+1) + (1-\eta)x(n-M)$$
$\eta$ fractional delay in samples

Difference Equation of simple flanger $$y(n)=x(n)+gx(n-M(n))$$

Delay line length
$$M(n) = M_0 + M_0Asin(2\pi \phi), \phi=nfT_s$$
f rate of flanger (speed of notch movement),
A maximum delay swing fixed,
$M_0$ average delay length fixed,
$T_s$ rate of sampling.
when $$\phi=1/8, sin(2\pi \phi)=1$$
Delay range is $$M_0\pm width=441 \pm floor(132.3) = [309, 573]$$ of $264$ values of phase $i=1,\cdots \times$ ratio $2.27\times 10^{-5}$ per iteration
"""

x=0
y=1
print(x,y)
def adder(i=1):
  global x
  y=1
  x = x + i*2
  y = y + i*2
  print(x,y)

for b in (1,2,3,4,5):
  adder()
print(x,y)

o = [0,0,0]
o =[1,2,3,4]
o[0:2]

